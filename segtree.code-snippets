{
	"default": {
		"prefix": [
			"segtree"
		],
	"body": [
		
			  "struct node{",
			  "    ll val;",
			  "    ll ind;",
			  "   node(){}",
			  "    node(ll v,ll i){val=v;ind=i;}",
			  "};",
			  "struct segtree{",
			  "    ll n;",
			  "    vl arr;",
			  "    vector<node> tree;",
			  "    segtree(ll n,vl &temp){",
			  "        this->n=n;",
			  "        this->arr=temp;",
			  "        tree.resize(4*n);",
			  "    }",
			  "    void build(ll node,ll l,ll r){",
			  "        if(l==r){",
			  "            tree[node].val=arr[l-1];",
			  "            tree[node].ind=l;",
			  "            return;",
			  "        }",
			  "        ll mid=(l+r)/2;",
			  "        build(2*node,l,mid);",
			  "        build(2*node+1,mid+1,r);",
			  "        if(tree[2*node].val>=tree[2*node+1].val){",
			  "            tree[node].val=tree[2*node].val;",
			  "            tree[node].ind=tree[2*node].ind;",
			  "        }",
			  "        else{",
			  "            tree[node].val=tree[2*node+1].val;",
			  "            tree[node].ind=tree[2*node+1].ind;",
			  "        }",
			  "    }",
			  "    void update(ll node,ll l,ll r,ll i,ll val){",
			  "        if(l==r){",
			  "            tree[node].val=val;",
			  "          ",
			  "            return;",
			  "        }",
			  "        ll mid=(l+r)/2;",
			  "        if(i<=mid)update(2*node,l,mid,i,val);",
			  "        else update(2*node+1,mid+1,r,i,val);",
			  "        if(tree[2*node].val>=tree[2*node+1].val){",
			  "            tree[node].val=tree[2*node].val;",
			  "            tree[node].ind=tree[2*node].ind;",
			  "        }",
			  "        else{",
			  "            tree[node].val=tree[2*node+1].val;",
			  "            tree[node].ind=tree[2*node+1].ind;",
			  "        }",
			  "    }",
			  "    node query(ll node,ll l,ll r,ll val){",
			  "        if(l==r){",
			  "            return tree[node];",
			  "        }",
			  "        ll mid=(l+r)/2;",
			  "        if(val<=tree[2*node].val){",
			  "            return query(2*node,l,mid,val);",
			  "        }",
			  "        else{",
			  "            return query(2*node+1,mid+1,r,val);",
			  "        }",
			  "    }",
			  "    bool ck(ll m){",
			  "        if(tree[1].val>=m)return true;",
			  "        return false;",
			  "    }",
			  "    void print_tree(){",
			  "        rep(i,1,4*n,1){",
			  "            cout<<tree[i].val<<\" \";",
			  "        }",
			  "        cout<<endl;",
			  "    }",
			  "};"
		
	],
	}
}
