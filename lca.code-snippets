{   
	"default": {
	"prefix": "lca",
	"body": [
	  "ll nodes=0,maxm=0;",
	  "vector<vl>lca;",
	  "vector<bool>vis;",
	  "vl dis;",
	  "void dfs(ll v){",
	  "    vis[v]=true;",
	  "    ",
	  "    for(auto u:adj[v]){",
	  "        if(!vis[u]){",
	  "            dis[u]=dis[v]+1;",
	  "            lca[u][0]=v; ",
	  "            dfs(u);",
	  "        }",
	  "    }",
	  "}",
	  "ll find_lca(ll u,ll v){",
	  "    if(dis[v]>dis[u])swap(u,v);",
	  "    ll d=dis[u]-dis[v];",
	  "    while(d>0){",
	  "        ll i=log2(d);",
	  "        u=lca[u][i];",
	  "        d-=1<<i;",
	  "    }",
	  "    if(u==v)return u;",
	  "",
	  "    for(int i=maxm;i>=0;i--){",
	  "        if(lca[u][i]!=-1 and  lca[u][i]!=lca[v][i]){",
	  "            u=lca[u][i];",
	  "            v=lca[v][i];",
	  "        }",
	  "    }",
	  "    return lca[u][0];",
	  "}",
	  "void solve()",
	  "{ ",
	  "        ni1(n);",
	  "",
	  "",
	  "        nodes=n+1;",
	  "        maxm=log2(n+1);",
	  "        adj.resize(nodes);",
	  "        lca=vector<vl>(nodes,vl(maxm+1,-1));",
	  "        vis=vector<bool>(nodes,false);",
	  "        dis=vector<ll>(nodes,0);",
	  "        rep(i,0,n-1,1){",
	  "            ni2(u,v);",
	  "            adj[u].pb(v);",
	  "            adj[v].pb(u);",
	  "        }",
	  "        dfs(1);",
	  "        for(ll j=1;j<=maxm;j++){",
	  "            for(ll i=1;i<nodes;i++){",
	  "                if(lca[i][j-1]!=-1)",
	  "                lca[i][j]=lca[lca[i][j-1]][j-1];",
	  "            }",
	  "        }",
	  "",
	  "}"
	],
	"description": "find the lca of two nodes in a tree"
  }
}