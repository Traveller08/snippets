{
	"default": {
		"prefix": [
			"lazy_segtree"
		],
	"body": [
		
			  "struct node{",
			  "    ll val;",
			  "    ll lazy;",
			  "    node(){val=0;lazy=0;}",
			  "    node(ll v){val=v;lazy=0;}",
			  "};",
			  "struct segtree{",
			  "    ll n;",
			  "    vector<node>tree;",
			  "    vl arr;",
			  "",
			  "    segtree(ll n,vl &a){",
			  "        this->n=n;",
			  "        this->arr=a;",
			  "        tree.resize(4*n);",
			  "    }",
			  "    void build(ll node,ll l,ll r){",
			  "        if(l==r){",
			  "            tree[node]=arr[l-1];",
			  "            return;",
			  "        }",
			  "        ll mid=(l+r)/2;",
			  "        build(2*node,l,mid);",
			  "        build(2*node+1,mid+1,r);",
			  "        tree[node]=tree[2*node].val+tree[2*node+1].val;",
			  "    }",
			  "    // range update using lazy propagation",
			  "    void update(ll node,ll l,ll r,ll i,ll j,ll val){",
			  "        if(tree[node].lazy!=0){",
			  "            tree[node].val+=tree[node].lazy;",
			  "",
			  "            if(l!=r){",
			  "                tree[2*node].lazy+=tree[node].lazy;",
			  "                tree[2*node+1].lazy+=tree[node].lazy;",
			  "            }",
			  "            tree[node].lazy=0;",
			  "        }",
			  "        ll mid=(l+r)/2;",
			  "        if(i>r or j<l) return;",
			  "        if(i<=l and j>=r){",
			  "            ll nn=(l-r+1)*val;",
			  "            tree[node].val+=nn;",
			  "            if(l!=r){",
			  "                tree[2*node].lazy+=val;",
			  "                tree[2*node+1].lazy+=val;",
			  "            }",
			  "            return;",
			  "        }",
			  "        update(2*node,l,mid,i,j,val);",
			  "        update(2*node+1,mid+1,r,i,j,val);",
			  "        tree[node].val=tree[2*node].val+tree[2*node+1].val;",
			  "    }",
			  "",
			  "",
			  "    ll query(ll node,ll x,ll l,ll r){",
			  "        if(tree[node].lazy!=0){",
			  "            tree[node].val+=tree[node].lazy;",
			  "            if(l!=r){",
			  "                tree[2*node].lazy+=tree[node].lazy;",
			  "                tree[2*node+1].lazy+=tree[node].lazy;",
			  "            }",
			  "            tree[node].lazy=0;",
			  "        }",
			  "        if(l==r){",
			  "            return tree[node].val;",
			  "        }",
			  "        ll mid=(l+r)/2;",
			  "        if(x<=mid)return query(2*node,x,l,mid);",
			  "        else return query(2*node+1,x,mid+1,r);",
			  "    }",
			  "    void print_v(ll n1){",
			  "        for(int i=1;i<=n1;i++){",
			  "            cout<<tree[i].val<<\" \";",
			  "        }cout<<endl;",
			  "    }",
			  "};"
		
	],
	}
}
